package ac.technion.iem.ontobuilder.matching.algorithms.line2.misc;

import java.util.Iterator;
import java.util.Vector;

import ac.technion.iem.ontobuilder.matching.algorithms.line2.meta.AbstractMetaAlgorithm;
import ac.technion.iem.ontobuilder.matching.algorithms.line2.meta.MetaAlgorithmRunningException;
import ac.technion.iem.ontobuilder.matching.meta.aggregators.AbstractGlobalAggregator;
import ac.technion.iem.ontobuilder.matching.meta.aggregators.AbstractLocalAggregator;
import ac.technion.iem.ontobuilder.matching.meta.match.AbstractMapping;
import ac.technion.iem.ontobuilder.matching.meta.statistics.TAStatistics;

/**
 * <p>Title: SMThersholdAlgorithm</p>
 * Extends {@link AbstractMetaAlgorithm}
 * Implements {@link ThresholdAlgorithm} and {@link NonUniformMetaAlgorithm}
 */
public class SMThersholdAlgorithm extends AbstractMetaAlgorithm implements ThresholdAlgorithm,
    NonUniformMetaAlgorithm
{
    /**
     * Constructs a default SMThersholdAlgorithm
     */
    protected SMThersholdAlgorithm()
    {
        super(true);
        setAlgorithmName("Schema Mapping Threshold Algorithm");
    }// parallel algorithm

    /**
     * Constructs a SMThersholdAlgorithm with TopK parameter k, an Abstract Global Aggregator and
     * Abstract Local Aggregator
     * 
     * @param k the TopK parameter
     * @param globalArg the {@link AbstractGlobalAggregator}
     * @param localArg the {@link AbstractLocalAggregator}
     */
    public SMThersholdAlgorithm(int k, AbstractGlobalAggregator globalArg,
        AbstractLocalAggregator localArg)
    {
        this();
        this.k = k;
        this.globalArg = globalArg;
        this.localArg = localArg;
    }

    /**
     * Run the algorithm
     */
    public void runAlgorithm() throws MetaAlgorithmRunningException
    {
        try
        {
            if (isUsingStatistics())
                initStatistics();
            super.runAlgorithm();// run algorithms A1,...Am then start parallel algorithm
        }
        catch (Throwable e)
        {
            e.printStackTrace();
            abnormalTermination();
            throw new MetaAlgorithmRunningException(e.getMessage());
        }
    }

    /**
     * Check if the algorithm can stop - due to reaching the threshold with one of the mappings, of
     * finished running
     * 
     * @return <code>true</code> if can halt
     */
    protected boolean canHalt()
    {
        // debug
        // System.out.println("checking if can halt..");
        // ***
        double[] localMappingScores = new double[numOfMatchingAlgorithms];
        for (int i = 0; i < numOfMatchingAlgorithms; i++)
            localMappingScores[i] = localArg.calcArgValue(lastMappings[i], matrixs[i]);
        double thresholdTA = globalArg.calcArgValue(localMappingScores);
        boolean canHalt = isExistKMappingWiteScore(thresholdTA);
        if (isUsingStatistics())
            ((TAStatistics) statistics).setCurrentTopKMappings(currentGeneratedTopK());
        return (thresholdTA == 0 || canHalt || stopReached() || checkInfiniteTermination());
    }

    /**
     * Get the index of the matching algorithm with the minimum heuristic value
     */
    public int progressWith()
    {
        int with = 0;
        double minVal = Double.MAX_VALUE;
        for (int i = 0; i < numOfMatchingAlgorithms; i++)
        {
            if (heuristicValues[i] < minVal)
            {
                with = i;
                minVal = heuristicValues[i];
            }
        }

        if (debugMode)
            System.out.println("Progress with:" + with + " Heuristic value:" +
                heuristicValues[with] + "\n");
        return with;
    }

    /**
     * Notify the correct thread with the new mapping
     * 
     * @param tid the thread id
     * @param mapping an {@link AbstractMapping}
     */
    public synchronized void notifyNewMapping(int tid, AbstractMapping mapping)
    {

        // perform local and global aggerators calculation
        // first check if not seen yet this mappings in one of the sorted lists
        newMapping(tid, mapping);
        // /***
        // remeber the last mapping generated by TKM in tid
        lastMappings[tid] = mapping;
        // System.out.println("calling "+tid+" to wait");
        maThreads[tid].waitForNextStep();
        synchronizer++;
        if (synchronizer == numOfMatchingAlgorithms)
        {
            synchronizer = 0;
            if (isUsingStatistics())
                statistics.increaseIterationsCount();
            currentStep++;
            // (b) check halt condition
            if (canHalt())
            {
                for (int i = 0; i < numOfMatchingAlgorithms; i++)
                {
                    maThreads[i].die();
                }
                // run halt
                finished();
            }
            else
            {
                for (int i = 0; i < numOfMatchingAlgorithms; i++)
                {
                    // System.out.println("calling "+i+" to continue");
                    maThreads[i].continueNextStep();
                }
            }
        }
    }

    /**
     * Notify the correct thread with the new heuristic value
     * 
     * @param tid the thread id
     * @param alpha an {@link AbstractMapping}
     * @param betas a vector of {@link AbstractMapping}
     */
    public synchronized void notifyNewHeuristicMappings(int tid, AbstractMapping alpha,
        Vector<AbstractMapping> betas)
    {
        double[] localMappingScores = new double[numOfMatchingAlgorithms];
        if (lastTidProgressedWith == tid)
        {
            double alphaVal, maxBetaVal = Double.MIN_VALUE, localVal;
            alphaVal = localArg.calcArgValue(alpha, matrixs[tid]);
            Iterator<AbstractMapping> it = betas.iterator();
            while (it.hasNext())
            {
                localVal = localArg.calcArgValue((AbstractMapping) it.next(), matrixs[tid]);
                maxBetaVal = maxBetaVal > localVal ? maxBetaVal : localVal;
            }
            // System.out.println("tid:"+tid+" beta val:"+maxBetaVal);

            lastTidHeuristicXi[tid] = Math.max(maxBetaVal, alphaVal); // save heuristic valuation -
                                                                      // epsilon

        }

        for (int i = 0; i < numOfMatchingAlgorithms; i++)
            localMappingScores[i] = (i == tid) ? lastTidHeuristicXi[tid] : localArg.calcArgValue(
                lastMappings[i], matrixs[i]);
        // added 8/2/04
        lastLocalXiScores = localMappingScores;
        // end added
        heuristicValues[tid] = globalArg.calcArgValue(lastLocalXiScores);

        // debug debugString.append(
        // if (lastTidProgressedWith != -1)
        if (debugMode)
        {
            System.out.print("tid:" + tid + " delta:" +
                (lastTidHeuristicXi[tid] - localArg.calcArgValue(lastMappings[tid], matrixs[tid])) +
                "\n");
            System.out.println("tid:" + tid + " TA value:" + heuristicValues[tid]);
        }

        maThreads[tid].waitForNextStep();
        synchronizer++;
        if (synchronizer == numOfMatchingAlgorithms)
        {
            synchronizer = 0;
            if (isUsingStatistics())
                statistics.increaseIterationsCount();
            currentStep++;
            // progress non uniformly with one TKM
            int progressWith = progressWith();
            lastTidProgressedWith = progressWith;
            try
            {
                // debug
                // System.out.println("continue with:"+progressWith);
                // ****
                lastMappings[progressWith] = maThreads[progressWith].continueInOneStep();
            }
            catch (Throwable e)
            {
                e.printStackTrace();
            }
            // (a)
            newMapping(tid, lastMappings[progressWith]);
            // (b) check halt condition
            if (canHalt())
            {
                for (int i = 0; i < numOfMatchingAlgorithms; i++)
                {
                    maThreads[i].die();
                }
                // run halt
                finished();
            }
            else
            {
                for (int i = 0; i < numOfMatchingAlgorithms; i++)
                {
                    // System.out.println("calling "+i+" to continue");
                    maThreads[i].continueNextStep();
                }
            }
        }
    }

    /**
     * Initialise statistics
     */
    protected void initStatistics()
    {
        super.initStatistics();
        ((TAStatistics) statistics).setThreadsCount(numOfMatchingAlgorithms);
    }

    /**
     * Initialise the statistics instance
     */
    public void useStatistics()
    {
        statistics = new TAStatistics(this, o1.getName(), o2.getName());
    }

    /**
     * Not implemented
     */
    public void reset()
    {
    }
}
